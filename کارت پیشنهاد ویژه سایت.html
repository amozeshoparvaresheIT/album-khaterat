<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>دسترسی ویژه نوآ - آموزش و پرورش IT</title>
    <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css" rel="stylesheet" type="text/css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Vazir, Tahoma, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            padding: 20px;
            color: #e2e8f0;
            direction: rtl;
        }

        .card-container {
            position: relative;
            width: 100%;
            max-width: 420px;
            transform-style: preserve-3d;
            perspective: 1000px;
            margin: 0 auto;
        }

        .card {
            background: linear-gradient(145deg, rgba(120, 53, 15, 0.8) 0%, rgba(68, 28, 7, 0.9) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 28px;
            padding: 30px 25px;
            color: #e2e8f0;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 190, 120, 0.25) inset;
            position: relative;
            z-index: 1;
            overflow: hidden;
            transform-style: preserve-3d;
            border: 1px solid rgba(255, 165, 0, 0.2);
        }

        .card-header {
            text-align: center;
            margin-bottom: 20px;
            transform: translateZ(20px);
        }

        .card-badge {
            display: inline-block;
            background: linear-gradient(45deg, #f59e0b, #f97316);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 10px;
            box-shadow: 0 4px 10px rgba(245, 158, 11, 0.3);
        }

        .card-title {
            font-size: 1.6rem;
            font-weight: 800;
            color: #fef3c7;
            margin-bottom: 5px;
            transform: translateZ(20px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .card-subtitle {
            font-size: 0.95rem;
            color: #d1d5db;
            transform: translateZ(20px);
        }

        .card-price {
            font-size: 3.2rem;
            font-weight: 800;
            color: #ffffff;
            margin: 15px 0;
            text-align: center;
            transform: translateZ(20px);
            direction: ltr;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-price .currency {
            font-size: 1.8rem;
            font-weight: 600;
            vertical-align: super;
            margin-left: 5px;
            color: #fdba74;
        }

        .card-price .period {
            font-size: 1rem;
            font-weight: 500;
            color: #d1d5db;
            margin-right: 10px;
        }

        .card-description {
            font-size: 0.95rem;
            color: #e5e7eb;
            margin-bottom: 25px;
            line-height: 1.7;
            text-align: center;
            transform: translateZ(20px);
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border-right: 3px solid #f59e0b;
        }

        .features-list {
            list-style: none;
            padding: 0;
            margin-bottom: 30px;
            transform: translateZ(20px);
        }

        .features-list li {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            margin-bottom: 15px;
            color: #e5e7eb;
            padding: 8px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        .features-list li:last-child {
            border-bottom: none;
        }

        .feature-icon {
            width: 24px;
            height: 24px;
            margin-left: 12px;
            color: #f59e0b;
            flex-shrink: 0;
        }

        .rotating-disc-svg {
            width: 20px;
            height: 20px;
            margin-left: 12px;
            animation: spin 3s linear infinite;
            flex-shrink: 0;
        }

        .rotating-disc-svg circle {
            stroke: #FDBA74;
            stroke-width: 2;
            stroke-dasharray: 10 5;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .cta-button {
            background: linear-gradient(45deg, #f59e0b, #f97316);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #ffffff;
            font-weight: 700;
            font-size: 1.05rem;
            padding: 16px 0;
            width: 100%;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transform: translateZ(20px);
            font-family: Vazir, Tahoma, sans-serif;
        }

        .cta-button:hover {
            background: linear-gradient(45deg, #fbbf24, #fb923c);
            transform: translateY(-3px) scale(1.02) translateZ(20px);
            box-shadow: 0 12px 25px rgba(245, 158, 11, 0.6);
        }

        .cta-button:active {
            transform: translateY(-1px) scale(0.98) translateZ(20px);
            background: linear-gradient(45deg, #d97706, #ea580c);
        }

        .card-footer {
            text-align: center;
            margin-top: 20px;
            font-size: 0.8rem;
            color: #9ca3af;
            transform: translateZ(20px);
        }

        #energy-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 0;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        /* رسپانسیو */
        @media (max-width: 480px) {
            .card {
                padding: 25px 20px;
            }
            
            .card-title {
                font-size: 1.4rem;
            }
            
            .card-price {
                font-size: 2.8rem;
            }
            
            .card-description {
                font-size: 0.9rem;
                padding: 12px;
            }
            
            .features-list li {
                font-size: 0.85rem;
            }
        }

        @media (max-width: 360px) {
            .card {
                padding: 20px 15px;
            }
            
            .card-title {
                font-size: 1.3rem;
            }
            
            .card-price {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="card-container" id="cardContainer">
        <canvas id="energy-canvas"></canvas>
        <div class="card" data-tilt data-tilt-max="10" data-tilt-speed="400" data-tilt-perspective="1000" data-tilt-glare data-tilt-max-glare="0.2">
            <div class="card-header">
                <div class="card-badge">پیشنهاد ویژه</div>
                <h2 class="card-title">دسترسی طلایی آموزش IT</h2>
                <p class="card-subtitle">ارائه شده توسط AmoozeshParvareshIT</p>
            </div>
            
            <p class="card-price">
                <span class="period">ماهیانه</span>
                ۱۹۹<span class="text-3xl align-baseline">,۰۰۰</span>
                <span class="currency">تومان</span>
            </p>
            
            <p class="card-description">
                با این پلن طلایی، مهارت‌های IT خود را به سطح حرفه‌ای برسانید. دسترسی نامحدود به تمامی دوره‌ها و پشتیبانی VIP دریافت کنید.
            </p>
            
            <ul class="features-list">
                <li>
                    <svg class="rotating-disc-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    دسترسی به بیش از ۱۰۰ دوره تخصصی
                </li>
                <li>
                    <svg class="rotating-disc-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    پشتیبانی اختصاصی ۲۴ ساعته
                </li>
                <li>
                    <svg class="rotating-disc-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    پروژه‌های عملی و رزومه‌سازی
                </li>
                <li>
                    <svg class="rotating-disc-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    گواهینامه‌های معتبر بین‌المللی
                </li>
                <li>
                    <svg class="rotating-disc-svg" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="12" cy="12" r="8"/>
                    </svg>
                    جلسات مشاوره شغلی اختصاصی
                </li>
            </ul>
            
            <button class="cta-button">همین حالا شروع کنید</button>
            
            <div class="card-footer">
                ضمانت بازگشت وجه تا ۳۰ روز
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
        }
    }
    </script>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/vanilla-tilt@1.7.2/dist/vanilla-tilt.min.js"></script>

    <script type="module">
        import * as THREE from 'three';

        const DEBUG = false;
        
        function log(...args) {
            if (DEBUG) {
                console.log('[FieryCard]', ...args);
            }
        }
        
        function warn(...args) {
            if (DEBUG) {
                console.warn('[FieryCard]', ...args);
            }
        }

        let scene, camera, renderer, fieryBandMesh;
        let uniforms;
        let material;

        const cardContainer = document.getElementById('cardContainer');
        const canvas = document.getElementById('energy-canvas');

        const bandVertexShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            void main() {
                vUv = uv;
                vPosition = position;
                
                vec3 newPosition = position;
                
                float distortionAmount = 0.02; 
                float distortion = noise(vec2(position.x * 0.05 + time * 0.1, position.y * 0.05 - time * 0.15)) * distortionAmount;
                
                vec2 normalizedPos = normalize(position.xy);
                newPosition.x += normalizedPos.x * distortion;
                newPosition.y += normalizedPos.y * distortion;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
            }
        `;

        const fieryBandFragmentShader = `
            uniform float time;
            uniform vec3 fireColorBase;
            uniform vec3 fireColorHot;
            uniform vec3 fireColorCool;
            varying vec2 vUv;
            varying vec3 vPosition;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }
            
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                
                vec2 u = f * f * (3.0 - 2.0 * f);
                
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            
            float turbulence(vec2 st, float baseFreq, int octaves) {
                float value = 0.0;
                float amplitude = 1.0;
                float frequency = baseFreq;
                
                for (int i = 0; i < octaves; i++) {
                    value += amplitude * abs(noise(st * frequency));
                    st = st * 1.4 + vec2(3.2, 1.7); 
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }
                
                return value;
            }

            void main() {
                float slowTime = time * 0.4;
                float mediumTime = time * 0.8;
                float fastTime = time * 1.6;
                
                vec2 centeredUv = vUv - vec2(0.5);
                float angle = atan(centeredUv.y, centeredUv.x);
                float normalizedAngle = (angle / (2.0 * 3.14159)) + 0.5;
                float radius = length(centeredUv) * 2.0;
                
                
                float flowSpeed = 2.0;
                float flowFrequency = 3.0;
                float baseFlow = sin(normalizedAngle * flowFrequency * 6.28318 + mediumTime * flowSpeed);
                baseFlow = baseFlow * 0.5 + 0.5; 
                
                vec2 noiseCoord1 = vec2(
                    normalizedAngle * 8.0 + mediumTime * 0.3,
                    vUv.y * 4.0 - mediumTime * 0.4
                );
                float fireDetail1 = turbulence(noiseCoord1, 1.0, 4);
                
                vec2 noiseCoord2 = vec2(
                    normalizedAngle * 6.0 - mediumTime * 0.5,
                    vUv.y * 3.0 + mediumTime * 0.3
                );
                float fireDetail2 = turbulence(noiseCoord2, 1.5, 3);
                
                vec2 emberCoord = vec2(
                    normalizedAngle * 10.0,
                    mod(vUv.y * 3.0 - fastTime * 0.5, 3.0)
                );
                float embers = noise(emberCoord * 8.0);
                embers = pow(embers, 3.0) * smoothstep(0.4, 0.6, vUv.y);
                
                float widthModulation = 1.0 - pow(abs(vUv.y - 0.5) * 1.8, 2.0);
                widthModulation = clamp(widthModulation, 0.3, 1.0);
                
                float mainFlicker = 0.92 + 0.08 * sin(fastTime * 7.7);
                float microFlicker = 0.95 + 0.05 * sin(fastTime * 30.0) * sin(fastTime * 17.3);
                float combinedFlicker = mainFlicker * microFlicker;
                
                float fireDetail = fireDetail1 * 0.6 + fireDetail2 * 0.4;
                fireDetail = pow(fireDetail, 1.2); 
                
                float baseIntensity = 0.7 + 0.3 * baseFlow;
                float turbulentIntensity = baseIntensity * fireDetail * widthModulation * combinedFlicker;
                
                float fineDetail = noise(noiseCoord1 * 3.0 + fastTime * 0.1) * 0.2;
                turbulentIntensity += fineDetail * widthModulation;
                
                turbulentIntensity += embers * 0.2;
                
                float finalIntensity = smoothstep(0.1, 0.9, turbulentIntensity);
                
                vec3 deepRed = vec3(0.7, 0.05, 0.01);    
                vec3 midOrange = fireColorBase;          
                vec3 brightYellow = vec3(1.0, 0.9, 0.3);   
                vec3 hotWhite = vec3(1.0, 1.0, 0.95);    
                
                vec3 finalColor;
                
                if (finalIntensity < 0.3) {
                    float t = finalIntensity / 0.3;
                    finalColor = mix(deepRed, midOrange, t);
                } 
                else if (finalIntensity < 0.7) {
                    float t = (finalIntensity - 0.3) / 0.4;
                    finalColor = mix(midOrange, brightYellow, t);
                }
                else {
                    float t = (finalIntensity - 0.7) / 0.3;
                    finalColor = mix(brightYellow, hotWhite, t);
                }
                
                float blueHint = pow(finalIntensity, 5.0) * 0.1;
                finalColor = mix(finalColor, vec3(0.7, 0.8, 1.0), blueHint);
                
                float alpha = finalIntensity * 2.0; 
                alpha = clamp(alpha, 0.0, 1.0);
                
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        function initThree() {
            log("Initializing Three.js");
            
            scene = new THREE.Scene();
            log("Scene created");
            
            camera = new THREE.OrthographicCamera(-1000, 1000, 1000, -1000, 0.1, 2000);
            camera.position.z = 100; 
            log("Camera created");

            try {
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    alpha: true, 
                    antialias: true 
                });
                
                renderer.setSize(800, 800); 
                log("Renderer created and sized to 800x800");
                
                uniforms = {
                    time: { value: 0.0 },
                    fireColorBase: { value: new THREE.Color(0xff6600) }, 
                    fireColorHot: { value: new THREE.Color(0xffffaa) },  
                    fireColorCool: { value: new THREE.Color(0xcc2200) }  
                };
                
                material = new THREE.ShaderMaterial({
                    vertexShader: bandVertexShader,
                    fragmentShader: fieryBandFragmentShader,
                    uniforms: uniforms,
                    transparent: true,
                    blending: THREE.AdditiveBlending, 
                    depthWrite: false, 
                    depthTest: false,  
                    side: THREE.DoubleSide 
                });
                log("Material created with shader");
                
                const placeHolderGeometry = new THREE.PlaneGeometry(50, 50); 
                fieryBandMesh = new THREE.Mesh(placeHolderGeometry, material);
                scene.add(fieryBandMesh);
                log("Initial mesh created and added to scene");
                
                createRingGeometry(); 
                
                animate();
                log("Animation started");
            } catch (error) {
                warn("Error in Three.js initialization:", error);
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = 'red';
                    ctx.font = '16px Arial';
                    ctx.fillText('Error initializing 3D graphics.', 10, 50);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); 
            
            if (uniforms) {
                uniforms.time.value += 0.016; 
                
                const time = uniforms.time.value;
                const hueShift = Math.sin(time * 0.1) * 0.05; 
                
                const baseColor = new THREE.Color();
                baseColor.setHSL(0.07 + hueShift, 0.9, 0.55); 
                uniforms.fireColorBase.value.copy(baseColor);
            }
            
            try {
                if (renderer && scene && camera) { 
                    renderer.render(scene, camera);
                }
            } catch (error) {
                warn("Error during rendering:", error);
            }
        }

        function createRingGeometry() {
            log("Creating ring geometry...");
            
            try {
                const cardRect = cardContainer.getBoundingClientRect(); 
                const cardWidth = cardRect.width;
                const cardHeight = cardRect.height;

                if (cardWidth === 0 || cardHeight === 0) {
                    warn("Card dimensions are zero. Retrying geometry creation shortly or check layout.");
                    return; 
                }
                log("Card dimensions (px):", cardWidth, cardHeight);
                
                const gap = 10;          
                const ringThickness = 20;   
                const cornerRadius = 24;    
                
                const outerWidth = cardWidth + 2 * (gap + ringThickness);
                const outerHeight = cardHeight + 2 * (gap + ringThickness);
                const outerRadius = cornerRadius + gap + ringThickness;
                
                const innerWidth = cardWidth + 2 * gap;
                const innerHeight = cardHeight + 2 * gap;
                const innerRadius = cornerRadius + gap;
                
                log("Ring dimensions:", {
                    outerWidth, outerHeight, outerRadius,
                    innerWidth, innerHeight, innerRadius
                });

                const canvasPadding = 40; 
                const canvasWidth = outerWidth + canvasPadding;
                const canvasHeight = outerHeight + canvasPadding;
                
                if (renderer) { 
                    renderer.setSize(canvasWidth, canvasHeight);
                    log("Canvas sized to:", canvasWidth, canvasHeight);
                }

                if (camera) { 
                    camera.left = -canvasWidth / 2;
                    camera.right = canvasWidth / 2;
                    camera.top = canvasHeight / 2;
                    camera.bottom = -canvasHeight / 2;
                    camera.updateProjectionMatrix();
                    log("Camera projection updated");
                }
                
                if (fieryBandMesh && fieryBandMesh.geometry) {
                    fieryBandMesh.geometry.dispose();
                }
                
                const outerShape = new THREE.Shape();
                outerShape.moveTo(-outerWidth/2 + outerRadius, -outerHeight/2); 
                outerShape.lineTo(outerWidth/2 - outerRadius, -outerHeight/2);  
                outerShape.quadraticCurveTo(outerWidth/2, -outerHeight/2, outerWidth/2, -outerHeight/2 + outerRadius); 
                outerShape.lineTo(outerWidth/2, outerHeight/2 - outerRadius);   
                outerShape.quadraticCurveTo(outerWidth/2, outerHeight/2, outerWidth/2 - outerRadius, outerHeight/2); 
                outerShape.lineTo(-outerWidth/2 + outerRadius, outerHeight/2);  
                outerShape.quadraticCurveTo(-outerWidth/2, outerHeight/2, -outerWidth/2, outerHeight/2 - outerRadius); 
                outerShape.lineTo(-outerWidth/2, -outerHeight/2 + outerRadius); 
                outerShape.quadraticCurveTo(-outerWidth/2, -outerHeight/2, -outerWidth/2 + outerRadius, -outerHeight/2); 
                
                const innerShapePath = new THREE.Path(); 
                innerShapePath.moveTo(-innerWidth/2 + innerRadius, -innerHeight/2);
                innerShapePath.lineTo(innerWidth/2 - innerRadius, -innerHeight/2);
                innerShapePath.quadraticCurveTo(innerWidth/2, -innerHeight/2, innerWidth/2, -innerHeight/2 + innerRadius);
                innerShapePath.lineTo(innerWidth/2, innerHeight/2 - innerRadius);
                innerShapePath.quadraticCurveTo(innerWidth/2, innerHeight/2, innerWidth/2 - innerRadius, innerHeight/2);
                innerShapePath.lineTo(-innerWidth/2 + innerRadius, innerHeight/2);
                innerShapePath.quadraticCurveTo(-innerWidth/2, innerHeight/2, -innerWidth/2, innerHeight/2 - innerRadius);
                innerShapePath.lineTo(-innerWidth/2, -innerHeight/2 + innerRadius);
                innerShapePath.quadraticCurveTo(-innerWidth/2, -innerHeight/2, -innerWidth/2 + innerRadius, -innerHeight/2);
                
                outerShape.holes.push(innerShapePath);
                log("Shapes with hole created");
                
                const ringGeometry = new THREE.ShapeGeometry(outerShape, 48); 
                log("Geometry created from shape");
                
                if (fieryBandMesh) { 
                    fieryBandMesh.geometry = ringGeometry;
                    fieryBandMesh.position.set(0, 0, 0); 
                }
                
                log("Ring geometry created successfully");

            } catch (error) {
                warn("Error creating ring geometry:", error);
                if (fieryBandMesh) {
                    const fallbackRadius = (cardContainer.offsetWidth || 360) / 2 + 15; 
                    fieryBandMesh.geometry = new THREE.RingGeometry(fallbackRadius, fallbackRadius + ringThickness, 48);
                    log("Created fallback circular ring geometry due to error.");
                }
            }
        }

        let resizeTimeout;
        function onWindowResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                log("Window resize detected, recreating ring geometry.");
                createRingGeometry();
            }, 150); 
        }

        function init() {
            log("Starting initialization");
            try {
                initThree();
                window.addEventListener('resize', onWindowResize); 

                if (typeof VanillaTilt !== 'undefined') {
                    VanillaTilt.init(document.querySelector(".card"), {
                        max: 10,    
                        speed: 400,   
                        glare: true,   
                        "max-glare": 0.2 
                    });
                    log("VanillaTilt.js initialized on .card");
                } else {
                    warn("VanillaTilt.js not loaded.");
                }

            } catch (error) {
                warn("Critical error during initialization:", error);
                if (document.body) {
                     document.body.innerHTML = "<div style='color:red; text-align:center; padding: 20px;'>Error loading visual elements. Please try refreshing.</div>" + document.body.innerHTML;
                } else {
                    document.addEventListener('DOMContentLoaded', () => {
                        if(document.body) {
                            document.body.innerHTML = "<div style='color:red; text-align:center; padding: 20px;'>Error loading visual elements. Please try refreshing.</div>" + document.body.innerHTML;
                        }
                    });
                }
            }
        }

        if (document.readyState === 'complete' || (document.readyState !== 'loading' && !document.documentElement.doScroll)) {
            log("Document already complete, initializing now");
            init();
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                log("DOMContentLoaded fired, initializing.");
                init();
            });
        }
    </script>
</body>
</html>